"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const imports_1 = require("./imports");
const validate_1 = require("./utils/validate");
const Q = require('q');
const supportedReturnAs = ['utf8', 'buffer', 'json', 'jsonWithDates'];
const promisedReadFile = Q.denodeify(fs_1.readFile);
function validateInput(methodName, path, returnAs) {
    const methodSignature = methodName + '(path, returnAs)';
    validate_1.validateArgument(methodSignature, 'path', path, ['string']);
    validate_1.validateArgument(methodSignature, 'returnAs', returnAs, ['string', 'undefined']);
    if (returnAs && supportedReturnAs.indexOf(returnAs) === -1) {
        throw new Error('Argument "returnAs" passed to ' + methodSignature
            + ' must have one of values: ' + supportedReturnAs.join(', '));
    }
}
exports.validateInput = validateInput;
;
// Matches strings generated by Date.toJSON()
// which is called to serialize date to JSON.
const jsonDateParser = (key, value) => {
    const reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
    if (typeof value === 'string') {
        if (reISO.exec(value)) {
            return new Date(value);
        }
    }
    return value;
};
const ErrJson = (path, err) => {
    const nicerError = new Error('JSON parsing failed while reading '
        + path + ' [' + err + ']');
    nicerError.originalError = err;
    return nicerError;
};
// ---------------------------------------------------------
// SYNC
// ---------------------------------------------------------
function sync(path, returnAs) {
    const retAs = returnAs || 'utf8';
    let data;
    try {
        data = fs_1.readFileSync(path, { encoding: retAs === 'buffer' ? null : 'utf8' });
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            // If file doesn't exist return undefined instead of throwing.
            return undefined;
        }
        // Otherwise rethrow the error
        throw err;
    }
    try {
        if (retAs === 'json') {
            data = imports_1.json.parse(data);
        }
        else if (retAs === 'jsonWithDates') {
            data = imports_1.json.parse(data, jsonDateParser);
        }
    }
    catch (err) {
        throw ErrJson(path, err);
    }
    return data;
}
exports.sync = sync;
;
// ---------------------------------------------------------
// ASYNC
// ---------------------------------------------------------
function async(path, returnAs) {
    return new Promise((resolve, reject) => {
        const retAs = returnAs || 'utf8';
        promisedReadFile(path, { encoding: retAs === 'buffer' ? null : 'utf8' })
            .then((data) => {
            // Make final parsing of the data before returning.
            try {
                if (retAs === 'json') {
                    resolve(imports_1.json.parse(data));
                }
                else if (retAs === 'jsonWithDates') {
                    resolve(imports_1.json.parse(data, jsonDateParser));
                }
                else {
                    resolve(data);
                }
            }
            catch (err) {
                reject(ErrJson(path, err));
            }
        })
            .catch((err) => (err.code === 'ENOENT' ? resolve(undefined) : reject(err)));
    });
}
exports.async = async;
;
//# sourceMappingURL=read.js.map