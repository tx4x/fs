// Generated by typings
// Source: https://raw.githubusercontent.com/xblox/core/9d4ac2555128d4f5e28ce00d72d76df0d800778a/index.d.ts
declare module '@xblox/core/primitives' {
	/**
	 * @returns whether the provided parameter is a JavaScript Array or not.
	 */
	export function isArray(array: any): array is any[];
	/**
	 * @returns whether the provided parameter is a JavaScript String or not.
	 */
	export function isString(str: any): str is string;
	/**
	 * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
	 */
	export function isStringArray(value: any): value is string[];
	/**
	 *
	 * @returns whether the provided parameter is of type `object` but **not**
	 *	`null`, an `array`, a `regexp`, nor a `date`.
	 */
	export function isObject(obj: any): boolean;
	/**
	 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
	 * @returns whether the provided parameter is a JavaScript Number or not.
	 */
	export function isNumber(obj: any): obj is number;
	/**
	 * @returns whether the provided parameter is a JavaScript Boolean or not.
	 */
	export function isBoolean(obj: any): obj is boolean;
	/**
	 * @returns whether the provided parameter is undefined.
	 */
	export function isUndefined(obj: any): boolean;
	/**
	 * @returns whether the provided parameter is undefined or null.
	 */
	export function isUndefinedOrNull(obj: any): boolean;
	/**
	 * @returns whether the provided parameter is an empty JavaScript Object or not.
	 */
	export function isEmptyObject(obj: any): obj is any;
	/**
	 * @returns whether the provided parameter is a JavaScript Function or not.
	 */
	export function isFunction(obj: any): obj is Function;
	/**
	 * @returns whether the provided parameters is are JavaScript Function or not.
	 */
	export function areFunctions(...objects: any[]): boolean;
	export type TypeConstraint = string | Function;
	export function validateConstraints(args: any[], constraints: TypeConstraint[]): void;
	export function validateConstraint(arg: any, constraint: TypeConstraint): void;
	/**
	 * Creates a new object of the provided class and will call the constructor with
	 * any additional argument supplied.
	 */
	export function create(ctor: Function, ...args: any[]): any;
	export interface IFunction0<T> {
	    (): T;
	}
	export interface IFunction1<A1, T> {
	    (a1: A1): T;
	}
	export interface IFunction2<A1, A2, T> {
	    (a1: A1, a2: A2): T;
	}
	export interface IFunction3<A1, A2, A3, T> {
	    (a1: A1, a2: A2, a3: A3): T;
	}
	export interface IFunction4<A1, A2, A3, A4, T> {
	    (a1: A1, a2: A2, a3: A3, a4: A4): T;
	}
	export interface IFunction5<A1, A2, A3, A4, A5, T> {
	    (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;
	}
	export interface IFunction6<A1, A2, A3, A4, A5, A6, T> {
	    (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;
	}
	export interface IFunction7<A1, A2, A3, A4, A5, A6, A7, T> {
	    (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;
	}
	export interface IFunction8<A1, A2, A3, A4, A5, A6, A7, A8, T> {
	    (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;
	}
	export interface IAction0 extends IFunction0<void> {
	}
	export interface IAction1<A1> extends IFunction1<A1, void> {
	}
	export interface IAction2<A1, A2> extends IFunction2<A1, A2, void> {
	}
	export interface IAction3<A1, A2, A3> extends IFunction3<A1, A2, A3, void> {
	}
	export interface IAction4<A1, A2, A3, A4> extends IFunction4<A1, A2, A3, A4, void> {
	}
	export interface IAction5<A1, A2, A3, A4, A5> extends IFunction5<A1, A2, A3, A4, A5, void> {
	}
	export interface IAction6<A1, A2, A3, A4, A5, A6> extends IFunction6<A1, A2, A3, A4, A5, A6, void> {
	}
	export interface IAction7<A1, A2, A3, A4, A5, A6, A7> extends IFunction7<A1, A2, A3, A4, A5, A6, A7, void> {
	}
	export interface IAction8<A1, A2, A3, A4, A5, A6, A7, A8> extends IFunction8<A1, A2, A3, A4, A5, A6, A7, A8, void> {
	}
	export type NumberCallback = (index: number) => void;
	export function count(to: number, callback: NumberCallback): void;
	export function count(from: number, to: number, callback: NumberCallback): void;
	export function countToArray(to: number): number[];
	export function countToArray(from: number, to: number): number[];

}
declare module '@xblox/core/collections' {
	export interface Key {
	    toString(): string;
	}
	export interface Entry<K, T> {
	    next?: Entry<K, T>;
	    prev?: Entry<K, T>;
	    key: K;
	    value: T;
	}
	/**
	 * A simple map to store value by a key object. Key can be any object that has toString() function to get
	 * string value of the key.
	 */
	export class LinkedMap<K extends Key, T> {
	    protected map: {
	        [key: string]: Entry<K, T>;
	    };
	    protected _size: number;
	    constructor();
	    readonly size: number;
	    get(k: K): T;
	    getOrSet(k: K, t: T): T;
	    keys(): K[];
	    values(): T[];
	    entries(): Entry<K, T>[];
	    set(k: K, t: T): boolean;
	    delete(k: K): T;
	    has(k: K): boolean;
	    clear(): void;
	    protected push(key: K, value: T): void;
	    protected pop(k: K): void;
	    protected peek(k: K): T;
	}
	/**
	 * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,
	 * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,
	 * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).
	 */
	export class BoundedLinkedMap<T> {
	    private limit;
	    protected map: {
	        [key: string]: Entry<string, T>;
	    };
	    private head;
	    private tail;
	    private _size;
	    private ratio;
	    constructor(limit?: number, ratio?: number);
	    readonly size: number;
	    set(key: string, value: T): boolean;
	    get(key: string): T;
	    getOrSet(k: string, t: T): T;
	    delete(key: string): T;
	    has(key: string): boolean;
	    clear(): void;
	    protected push(entry: Entry<string, T>): void;
	    private trim();
	}
	/**
	 * A subclass of Map<T> that makes an entry the MRU entry as soon
	 * as it is being accessed. In combination with the limit for the
	 * maximum number of elements in the cache, it helps to remove those
	 * entries from the cache that are LRU.
	 */
	export class LRUCache<T> extends BoundedLinkedMap<T> {
	    constructor(limit: number);
	    get(key: string): T;
	}
	/**
	 * A trie map that allows for fast look up when keys are substrings
	 * to the actual search keys (dir/subdir-problem).
	 */
	export class TrieMap<E> {
	    static PathSplitter: (s: string) => string[];
	    private _splitter;
	    private _root;
	    constructor(splitter: (s: string) => string[]);
	    insert(path: string, element: E): void;
	    lookUp(path: string): E;
	    findSubstr(path: string): E;
	    findSuperstr(path: string): TrieMap<E>;
	}
	export class ArraySet<T> {
	    private _elements;
	    constructor(elements?: T[]);
	    readonly size: number;
	    set(element: T): void;
	    contains(element: T): boolean;
	    unset(element: T): void;
	    readonly elements: T[];
	}
	/**
	 * Returns the last element of an array.
	 * @param array The array.
	 * @param n Which element from the end (default ist zero).
	 */
	export function tail<T>(array: T[], n?: number): T;
	export function equals<T>(one: T[], other: T[], itemEquals?: (a: T, b: T) => boolean): boolean;
	export function binarySearch<T>(array: T[], key: T, comparator: (op1: T, op2: T) => number): number;
	/**
	 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
	 * are located before all elements where p(x) is true.
	 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
	 */
	export function findFirst<T>(array: T[], p: (x: T) => boolean): number;
	/**
	 * Returns the top N elements from the array.
	 *
	 * Faster than sorting the entire array when the array is a lot larger than N.
	 *
	 * @param array The unsorted array.
	 * @param compare A sort function for the elements.
	 * @param n The number of elements to return.
	 * @return The first n elemnts from array when sorted with compare.
	 */
	export function top<T>(array: T[], compare: (a: T, b: T) => number, n: number): T[];
	/**
	 * @returns a new array with all undefined or null values removed. The original array is not modified at all.
	 */
	export function coalesce<T>(array: T[]): T[];
	/**
	 * Moves the element in the array for the provided positions.
	 */
	export function move(array: any[], from: number, to: number): void;
	/**
	 * @returns {{false}} if the provided object is an array
	 * 	and not empty.
	 */
	export function isFalsyOrEmpty(obj: any): boolean;
	/**
	 * Removes duplicates from the given array. The optional keyFn allows to specify
	 * how elements are checked for equalness by returning a unique string for each.
	 */
	export function distinct<T>(array: T[], keyFn?: (t: T) => string): T[];
	export function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean;
	export function firstIndex<T>(array: T[], fn: (item: T) => boolean): number;
	export function first<T>(array: T[], fn: (item: T) => boolean, notFoundValue?: T): T;
	export function commonPrefixLength<T>(one: T[], other: T[], equals?: (a: T, b: T) => boolean): number;
	export function flatten<T>(arr: T[][]): T[];
	export function range(to: number, from?: number): number[];
	export function fill<T>(num: number, valueFn: () => T, arr?: T[]): T[];
	export function index<T>(array: T[], indexer: (t: T) => string): {
	    [key: string]: T;
	};
	export function index<T, R>(array: T[], indexer: (t: T) => string, merger?: (t: T, r: R) => R): {
	    [key: string]: R;
	};
	/**
	 * Inserts an element into an array. Returns a function which, when
	 * called, will remove that element from the array.
	 */
	export function insert<T>(array: T[], element: T): () => void;

}
declare module '@xblox/core/utils' {
	export function StingEnum<T extends string>(o: Array<T>): {
	    [K in T]: K;
	};

}
declare module '@xblox/core' {
	}
